using System;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using WebAssemblySharp.Attributes;

namespace WebAssemblySharp.InterfaceGenerator;

[Generator]
public class InterfaceSourceGenerator: IIncrementalGenerator
{
    private static readonly String m_DefinitionAttributeName = nameof(WebAssemblyModuleDefinitionAttribute);
    private static readonly String m_DefinitionAttributeNameShort = nameof(WebAssemblyModuleDefinitionAttribute).Replace("Attribute", "");
    
    public void Initialize(IncrementalGeneratorInitializationContext p_Context)
    {
        
        
        
        IncrementalValuesProvider<InterfaceDeclarationSyntax> l_CalculatorClassesProvider = p_Context.SyntaxProvider.CreateSyntaxProvider(
            predicate: (SyntaxNode p_Node, CancellationToken p_CancelToken) =>
            {
                //the predicate should be super lightweight so it can quickly filter out nodes that are not of interest
                //it is basically called all of the time so it should be a quick filter
                return p_Node is InterfaceDeclarationSyntax l_InterfaceDeclarationSyntax && l_InterfaceDeclarationSyntax.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)) && HasAttribute(l_InterfaceDeclarationSyntax);
            },
            transform: (GeneratorSyntaxContext p_Ctx, CancellationToken p_CancelToken) =>
            {
                var l_ClassDeclaration = (InterfaceDeclarationSyntax)p_Ctx.Node;
                return l_ClassDeclaration;
            }
        );
        
        //next, we register the Source Output to call the Execute method so we can do something with these filtered items
        p_Context.RegisterSourceOutput(l_CalculatorClassesProvider, (p_SourceProductionContext, p_InterfaceClass) 
            => Execute(p_InterfaceClass, p_SourceProductionContext));
        
    }
    
    private static bool HasAttribute(InterfaceDeclarationSyntax p_InterfaceDeclaration)
    {
        
        // Check each attribute list for the desired annotation
        foreach (var l_AttributeList in p_InterfaceDeclaration.AttributeLists)
        {
            
            foreach (var l_Attribute in l_AttributeList.Attributes)
            {
                var l_AttributeName = l_Attribute.Name.ToString();
                
                if (l_AttributeName == m_DefinitionAttributeName || l_AttributeName == m_DefinitionAttributeNameShort)
                {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    private void Execute(InterfaceDeclarationSyntax p_InterfaceClass, SourceProductionContext p_Context)
    {
        string l_NameSpace = GetNamespace(p_InterfaceClass);

        if (String.IsNullOrEmpty(l_NameSpace))
            throw new Exception("No namespace found for interface " + p_InterfaceClass.Identifier.ToString());;
        
        StringBuilder l_Code = new StringBuilder();
        l_Code.AppendLine("// <auto-generated/>");
        
        l_Code.AppendLine("using System;");
        l_Code.AppendLine("using System.Threading.Tasks;");
        l_Code.AppendLine("");
        l_Code.AppendLine("namespace " + l_NameSpace + ";");
        l_Code.AppendLine("public partial interface " + p_InterfaceClass.Identifier.ToString());
        l_Code.AppendLine("{");
        l_Code.AppendLine("public ValueTask<int> add(int p_A, int p_B);");
        l_Code.AppendLine("}");
        
        
        p_Context.AddSource(l_NameSpace + "." + p_InterfaceClass.Identifier.ToString() + ".Generated", l_Code.ToString());
    }
    
    public string GetNamespace(BaseTypeDeclarationSyntax p_Syntax)
    {
        // If we don't have a namespace at all we'll return an empty string
        // This accounts for the "default namespace" case
        string l_NameSpace = string.Empty;

        // Get the containing syntax node for the type declaration
        // (could be a nested type, for example)
        SyntaxNode l_PotentialNamespaceParent = p_Syntax.Parent;

        // Keep moving "out" of nested classes etc until we get to a namespace
        // or until we run out of parents
        while (l_PotentialNamespaceParent != null &&
               !(l_PotentialNamespaceParent is NamespaceDeclarationSyntax)
               && !(l_PotentialNamespaceParent is FileScopedNamespaceDeclarationSyntax))
        {
            l_PotentialNamespaceParent = l_PotentialNamespaceParent.Parent;
        }

        // Build up the final namespace by looping until we no longer have a namespace declaration
        if (l_PotentialNamespaceParent is BaseNamespaceDeclarationSyntax l_NamespaceParent)
        {
            // We have a namespace. Use that as the type
            l_NameSpace = l_NamespaceParent.Name.ToString();

            // Keep moving "out" of the namespace declarations until we 
            // run out of nested namespace declarations
            while (true)
            {
                if (!(l_NamespaceParent.Parent is NamespaceDeclarationSyntax parent))
                {
                    break;
                }

                // Add the outer namespace as a prefix to the final namespace
                l_NameSpace = $"{l_NamespaceParent.Name}.{l_NameSpace}";
                l_NamespaceParent = parent;
            }
        }

        // return the final namespace
        return l_NameSpace;
    }
    
}